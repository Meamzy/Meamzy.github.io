<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mycopunk Mod Solver (Advanced Heuristics)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #111318;
            --bg-secondary: #1d2027;
            --bg-tertiary: #2a2e37;
            --text-primary: #f0f1f2;
            --text-secondary: #9ea3ae;
            --accent-primary: #ff7b00;
            --accent-secondary: #00aaff;
            --accent-danger: #e53e3e;
            --border-color: #3c414d;
            
            --rarity-green: #4caf50;
            --rarity-blue: #2196f3;
            --rarity-purple: #9c27b0;
            --rarity-orange: #ff9800;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #app-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 20px;
            padding: 20px;
            width: 100%;
            height: 100%;
        }

        #controls-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .controls-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .controls-header h1 { margin: 0; font-size: 1.5em; }
        .controls-header p { margin: 5px 0 0; color: var(--text-secondary); font-size: 0.9em; }

        .controls-body {
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .control-group h2 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-secondary); font-size: 0.9em; }
        .input-row { display: flex; gap: 15px; }

        input[type="number"] {
            width: 100%;
            padding: 10px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 1em;
        }

        #creator-canvas-container {
            background-color: var(--bg-primary);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            height: 220px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .radio-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .radio-group label {
            text-align: center; color: white; margin: 0; cursor: pointer; padding: 10px;
            border-radius: 6px; border: 2px solid transparent; font-weight: 600; transition: all 0.2s;
        }
        .radio-group input[type="radio"] { display: none; }
        #rarity-green:checked + label { border-color: white; box-shadow: 0 0 10px var(--rarity-green); }
        #rarity-blue:checked + label { border-color: white; box-shadow: 0 0 10px var(--rarity-blue); }
        #rarity-purple:checked + label { border-color: white; box-shadow: 0 0 10px var(--rarity-purple); }
        #rarity-orange:checked + label { border-color: white; box-shadow: 0 0 10px var(--rarity-orange); }
        label[for="rarity-green"] { background-color: var(--rarity-green); }
        label[for="rarity-blue"] { background-color: var(--rarity-blue); }
        label[for="rarity-purple"] { background-color: var(--rarity-purple); }
        label[for="rarity-orange"] { background-color: var(--rarity-orange); }

        .checkbox-container { display: flex; align-items: center; margin-top: 15px; }
        .checkbox-container input { margin-right: 10px; }

        button {
            width: 100%; padding: 12px; font-size: 1.1em; font-weight: bold; color: white;
            border: none; border-radius: 6px; cursor: pointer; transition: all 0.2s;
            background: linear-gradient(45deg, var(--accent-primary), #d16600);
        }
        button:hover:not(:disabled) { background: linear-gradient(45deg, #ff8c1a, #e67300); }
        button:disabled { background: var(--bg-tertiary); color: var(--text-secondary); cursor: not-allowed; }
        
        button.cancel-btn {
            background: linear-gradient(45deg, var(--accent-danger), #b92c2c);
        }
        button.cancel-btn:hover:not(:disabled) {
            background: linear-gradient(45deg, #f56565, #c53030);
        }

        #mod-list-container { max-height: 250px; overflow-y: auto; padding-right: 5px; }
        #mod-list { display: flex; flex-direction: column; gap: 10px; }
        .mod-item { display: flex; align-items: center; background-color: var(--bg-tertiary); padding: 8px; border-radius: 6px; }
        .mod-preview-canvas { width: 60px; height: 60px; background-color: var(--bg-primary); border-radius: 4px; margin-right: 15px; flex-shrink: 0; }
        .mod-item-info { flex-grow: 1; }
        .mod-item-info span { font-weight: 600; }
        .mod-item-info p { margin: 4px 0 0; font-size: 0.8em; color: var(--text-secondary); }
        .mod-delete-btn { background: transparent; border: none; cursor: pointer; padding: 5px; width: 32px; height: 32px; }
        .mod-delete-btn svg { fill: var(--text-secondary); transition: fill 0.2s; }
        .mod-delete-btn:hover svg { fill: #ff4d4d; }

        #canvas-container {
            background-color: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        canvas { display: block; }

        #status-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }

        @media (max-width: 1000px) {
            body { height: auto; overflow-y: auto; }
            #app-container { grid-template-columns: 1fr; }
            #controls-panel { order: 2; }
            #canvas-container { order: 1; height: 60vh; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <div class="controls-header">
                <h1>Mycopunk Solver</h1>
                <p>Design mods and find the perfect fit.</p>
            </div>
            <div class="controls-body">
                <div class="control-group">
                    <h2>Board Setup</h2>
                    <div class="input-row">
                        <div><label for="board-cols">Columns</label><input type="number" id="board-cols" value="7" min="2" max="15"></div>
                        <div><label for="board-rows">Rows</label><input type="number" id="board-rows" value="6" min="2" max="15"></div>
                    </div>
                </div>

                <div class="control-group">
                    <h2>Mod Creator</h2>
                    <label>Click in the area below to draw a shape:</label>
                    <div id="creator-canvas-container"><canvas id="creator-canvas"></canvas></div>
                    <div class="radio-group">
                        <input type="radio" id="rarity-green" name="rarity" value="#4caf50" checked><label for="rarity-green">Green</label>
                        <input type="radio" id="rarity-blue" name="rarity" value="#2196f3"><label for="rarity-blue">Blue</label>
                        <input type="radio" id="rarity-purple" name="rarity" value="#9c27b0"><label for="rarity-purple">Purple</label>
                        <input type="radio" id="rarity-orange" name="rarity" value="#ff9800"><label for="rarity-orange">Orange</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="priority-mod"><label for="priority-mod">Maximize this mod's connections</label>
                    </div>
                    <button id="add-mod-btn">Add Mod to List</button>
                </div>

                <div class="control-group">
                    <h2>Mod List</h2>
                    <div id="mod-list-container"><div id="mod-list"></div></div>
                </div>
                
                 <div class="control-group">
                    <h2>Solver</h2>
                    <button id="solve-btn" disabled>Solve Arrangement</button>
                 </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <div id="status-message"></div>
        </div>
    </div>

    <!-- 
        This script tag contains the logic for our Web Worker.
        By giving it a special type, the browser won't execute it immediately.
        We will read its content as a string and create a Blob URL to launch the worker,
        keeping everything neatly in a single HTML file.
    -->
    <script type="javascript/worker" id="solver-worker">
        // --- UTILITY CLASSES AND FUNCTIONS ---
        class Hex {
            constructor(q, r) { this.q = q; this.r = r; this.s = -q - r; }
            toString() { return `${this.q},${this.r}`; }
            add(other) { return new Hex(this.q + other.q, this.r + other.r); }
            subtract(other) { return new Hex(this.q - other.q, this.r - other.r); }
            rotate(center, steps = 1) {
                let vec = this.subtract(center);
                for (let i = 0; i < steps; i++) {
                    const { q, r, s } = vec;
                    vec = new Hex(-r, -s);
                }
                return vec.add(center);
            }
            distance(other) {
                return (Math.abs(this.q - other.q) 
                      + Math.abs(this.r - other.r) 
                      + Math.abs(this.s - other.s)) / 2;
            }
        }

        let isCancelled = false;
        let placementsChecked = 0;

        self.onmessage = function(e) {
            const { type, payload } = e.data;
            if (type === 'solve') {
                isCancelled = false;
                placementsChecked = 0;
                const solution = solve(payload);
                self.postMessage({ type: 'result', payload: { solution, placementsChecked } });
            } else if (type === 'cancel') {
                isCancelled = true;
            }
        };

        // --- CORE SOLVER LOGIC (RE-ARCHITECTED) ---

        /**
         * Pre-computes all possible valid placements for every mod on the board.
         * This is a critical step that enables the efficient heuristic-based search.
         * @returns {Map<number, Object[]>} A map from mod ID to an array of its possible placements.
         * Each placement object contains the mod, its absolute shape, and a unique key.
         */
        function precomputeAllPlacements(mods, boardHexes, boardGridSet) {
            const allPlacements = new Map();
            const rotationCenter = new Hex(0, 0);

            for (const mod of mods) {
                const modPlacements = [];
                const shape = mod.shape.map(h => new Hex(h.q, h.r));
                const uniqueRotations = new Map();

                // 1. Find unique rotations for the mod
                for (let i = 0; i < 6; i++) {
                    const rotatedShape = shape.map(h => h.rotate(rotationCenter, i));
                    const firstHex = rotatedShape[0];
                    const normalized = rotatedShape.map(h => h.subtract(firstHex));
                    const key = normalized.map(h => h.toString()).sort().join('|');
                    if (!uniqueRotations.has(key)) {
                        uniqueRotations.set(key, normalized);
                    }
                }

                // 2. For each unique rotation, find all valid board positions
                for (const rotation of uniqueRotations.values()) {
                    for (const boardHex of boardHexes) {
                        const absoluteShape = rotation.map(h => h.add(boardHex));
                        if (canPlace(absoluteShape, new Set(), boardGridSet)) {
                            const placementKey = absoluteShape.map(h => h.toString()).sort().join('|');
                            modPlacements.push({
                                mod,
                                absoluteShape,
                                key: placementKey
                            });
                        }
                    }
                }
                allPlacements.set(mod.id, modPlacements);
            }
            return allPlacements;
        }
        
        function canPlace(absoluteShape, occupiedHexes, boardGridSet) {
            for (const hex of absoluteShape) {
                const hexStr = hex.toString();
                if (!boardGridSet.has(hexStr) || occupiedHexes.has(hexStr)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * The new heuristic-driven backtracking solver.
         * It uses the "Minimum Remaining Values" (MRV) heuristic to guide its search.
         * Instead of picking an arbitrary empty cell, it identifies the most constrained
         * cell and tries to fill that one first, leading to much faster pruning of the search tree.
         */
        function backtrack(modsToPlace, occupiedHexes, currentPlacements, placementMap, boardHexes) {
            if (isCancelled) throw new Error('Cancelled');
            if (modsToPlace.length === 0) return currentPlacements;

            // --- HEURISTIC: Find the most constrained empty hex (Minimum Remaining Values) ---
            let bestHex = null;
            let minOptions = Infinity;
            let bestHexOptions = [];

            for (const hex of boardHexes) {
                const hexStr = hex.toString();
                if (!occupiedHexes.has(hexStr)) {
                    let optionsCount = 0;
                    const currentHexOptions = [];
                    // Count how many of the *remaining* mods can be placed here
                    for (const mod of modsToPlace) {
                        const placements = placementMap.get(mod.id);
                        for (const p of placements) {
                            if (p.absoluteShape.some(h => h.toString() === hexStr)) {
                                optionsCount++;
                                currentHexOptions.push(p);
                            }
                        }
                    }
                    
                    if (optionsCount < minOptions) {
                        minOptions = optionsCount;
                        bestHex = hex;
                        bestHexOptions = currentHexOptions;
                    }
                }
            }
            
            // If a cell has zero options, this branch is a dead end.
            if (minOptions === 0) {
                 // Check if remaining mods have any area. If not, we found a partial solution.
                const remainingArea = modsToPlace.reduce((sum, mod) => sum + mod.shape.length, 0);
                return remainingArea === 0 ? currentPlacements : null;
            }

            // --- BRANCH on the placements for the most constrained hex ---
            for (const placement of bestHexOptions) {
                placementsChecked++;
                 if (placementsChecked % 50000 === 0) {
                    self.postMessage({ type: 'progress', payload: { placementsChecked } });
                }

                // Check if this placement is valid given the current occupied hexes
                let isPlacementValid = true;
                for(const hex of placement.absoluteShape) {
                    if(occupiedHexes.has(hex.toString())) {
                        isPlacementValid = false;
                        break;
                    }
                }

                if (isPlacementValid) {
                    const modToPlace = placement.mod;
                    const remainingMods = modsToPlace.filter(m => m.id !== modToPlace.id);
                    
                    const shapeStrings = placement.absoluteShape.map(h => h.toString());
                    shapeStrings.forEach(s => occupiedHexes.add(s));

                    const newPlacements = [...currentPlacements, placement];
                    const result = backtrack(remainingMods, occupiedHexes, newPlacements, placementMap, boardHexes);
                    
                    if (isCancelled) throw new Error('Cancelled');
                    if (result) return result;

                    // Backtrack
                    shapeStrings.forEach(s => occupiedHexes.delete(s));
                }
            }

            return null; // No solution found from this path
        }
        
        // --- PRIORITY SOLVER & HELPERS ---
        function getHexNeighbors(hex) {
            const directions = [new Hex(1, 0), new Hex(1, -1), new Hex(0, -1), new Hex(-1, 0), new Hex(-1, 1), new Hex(0, 1)];
            return directions.map(dir => hex.add(dir));
        }

        function countConnections(placedPriorityMod, allPlacements) {
            if (!placedPriorityMod) return 0;
            const hexToModIdMap = new Map();
            allPlacements.forEach(p => {
                if (p.mod.id !== placedPriorityMod.mod.id) {
                    p.absoluteShape.forEach(h => hexToModIdMap.set(h.toString(), p.mod.id));
                }
            });
            const touchedModIds = new Set();
            placedPriorityMod.absoluteShape.forEach(hex => {
                getHexNeighbors(hex).forEach(neighbor => {
                    const neighborStr = neighbor.toString();
                    if (hexToModIdMap.has(neighborStr)) {
                        touchedModIds.add(hexToModIdMap.get(neighborStr));
                    }
                });
            });
            return touchedModIds.size;
        }

        function getBoardCenter(boardHexes) {
            if (boardHexes.length === 0) return new Hex(0, 0);
            const avgQ = boardHexes.reduce((sum, h) => sum + h.q, 0) / boardHexes.length;
            const avgR = boardHexes.reduce((sum, h) => sum + h.r, 0) / boardHexes.length;
            let q = Math.round(avgQ), r = Math.round(avgR), s = Math.round(-avgQ - avgR);
            const q_diff = Math.abs(q - avgQ), r_diff = Math.abs(r - avgR), s_diff = Math.abs(s - (-avgQ - avgR));
            if (q_diff > r_diff && q_diff > s_diff) q = -r - s;
            else if (r_diff > s_diff) r = -q - s;
            return new Hex(q, r);
        }

        function calculateSolutionQuality(solution, center) {
            let totalDistance = 0;
            let hexCount = 0;
            for (const placement of solution) {
                for (const hex of placement.absoluteShape) {
                    totalDistance += hex.distance(center);
                    hexCount++;
                }
            }
            return hexCount > 0 ? totalDistance / hexCount : Infinity;
        }

        function findBestPrioritySolution(board, mods, boardHexes, boardGridSet, allPlacements) {
            let bestSolutionFound = null;
            let maxConnections = -1;
            let bestSolutionQuality = Infinity; 
            const boardCenter = getBoardCenter(boardHexes);
            
            const priorityMod = mods.find(m => m.isPriority);
            const otherMods = mods.filter(m => m.id !== priorityMod.id).sort((a,b) => b.shape.length - a.shape.length);
            const priorityModPlacements = allPlacements.get(priorityMod.id);
            
            for (const placement of priorityModPlacements) {
                if (isCancelled) throw new Error('Cancelled');
                
                const occupied = new Set(placement.absoluteShape.map(h => h.toString()));
                const currentPlacements = [placement];
                const subSolution = backtrack(otherMods, occupied, currentPlacements, allPlacements, boardHexes);
                
                if (isCancelled) throw new Error('Cancelled');

                if (subSolution) {
                    const connections = countConnections(subSolution.find(p => p.mod.id === priorityMod.id), subSolution);
                    const quality = calculateSolutionQuality(subSolution, boardCenter);
                    
                    if (connections > maxConnections || (connections === maxConnections && quality < bestSolutionQuality)) {
                        maxConnections = connections;
                        bestSolutionQuality = quality;
                        bestSolutionFound = subSolution;
                        
                        const serializableSolution = bestSolutionFound.map(p => ({
                            mod: { ...p.mod, shape: p.mod.shape.map(h => ({q: h.q, r: h.r})) },
                            absoluteShape: p.absoluteShape.map(h => ({ q: h.q, r: h.r }))
                        }));
                        self.postMessage({ type: 'intermediate_solution', payload: { solution: serializableSolution, connections } });
                    }
                }
            }
            return bestSolutionFound;
        }

        // --- MAIN SOLVER ENTRY POINT ---
        function solve({ board, mods }) {
            try {
                const boardHexes = board.grid.map(h => new Hex(h.q, h.r));
                const boardGridSet = new Set(boardHexes.map(h => h.toString()));

                // 1. Major pre-computation step
                const allPlacements = precomputeAllPlacements(mods, boardHexes, boardGridSet);
                
                let solution;
                const priorityMod = mods.find(m => m.isPriority);

                if (priorityMod) {
                    solution = findBestPrioritySolution(board, mods, boardHexes, boardGridSet, allPlacements);
                } else {
                    const sortedMods = [...mods].sort((a, b) => b.shape.length - a.shape.length);
                    solution = backtrack(sortedMods, new Set(), [], allPlacements, boardHexes);
                }

                return solution ? solution.map(p => ({
                    mod: { ...p.mod, shape: p.mod.shape.map(h => ({q: h.q, r: h.r})) },
                    absoluteShape: p.absoluteShape.map(h => ({ q: h.q, r: h.r }))
                })) : null;

            } catch (e) {
                if (e.message === 'Cancelled') {
                    console.log('Solver execution cancelled.');
                    return null;
                }
                console.error("Solver error:", e);
                throw e;
            }
        }
    </script>

    <script type="module">
        class Hex {
            constructor(q, r) { this.q = q; this.r = r; this.s = -q - r; }
            toString() { return `${this.q},${this.r}`; }
            static fromString(str) {
                const [q, r] = str.split(',').map(Number);
                return new Hex(q, r);
            }
            add(other) { return new Hex(this.q + other.q, this.r + other.r); }
            subtract(other) { return new Hex(this.q - other.q, this.r - other.r); }
            
            distance(other) {
                return (Math.abs(this.q - other.q) 
                      + Math.abs(this.r - other.r) 
                      + Math.abs(this.s - other.s)) / 2;
            }

            rotate(center, steps = 1) {
                let vec = this.subtract(center);
                for (let i = 0; i < steps; i++) {
                    const { q, r, s } = vec;
                    vec = new Hex(-r, -s);
                }
                return vec.add(center);
            }
        }

        class ModSolverApp {
            constructor() {
                this.mainCanvas = document.getElementById('main-canvas');
                this.mainCtx = this.mainCanvas.getContext('2d');
                this.creatorCanvas = document.getElementById('creator-canvas');
                this.creatorCtx = this.creatorCanvas.getContext('2d');
                
                this.colsInput = document.getElementById('board-cols');
                this.rowsInput = document.getElementById('board-rows');
                this.addModBtn = document.getElementById('add-mod-btn');
                this.solveBtn = document.getElementById('solve-btn');
                this.modListContainer = document.getElementById('mod-list');
                this.statusMessageEl = document.getElementById('status-message');

                this.board = { cols: 7, rows: 6, grid: new Map(), renderProps: {} };
                this.creator = { cols: 8, rows: 7, grid: new Map(), shape: new Set(), renderProps: {} };
                this.mods = [];
                this.solution = null;
                this.isSolving = false;
                this.solverWorker = null;
                this.messageTimeout = null;

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.setupSolverWorker();
                this.loadMods();
                this.createGrids();
                this.resizeAndDrawAll();
                this.renderModList();
                this.updateSolveButtonState();
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeAndDrawAll());
                this.colsInput.addEventListener('change', () => this.handleBoardResize());
                this.rowsInput.addEventListener('change', () => this.handleBoardResize());
                this.creatorCanvas.addEventListener('click', (e) => this.handleCreatorClick(e));
                this.addModBtn.addEventListener('click', () => this.addModToList());
                this.solveBtn.addEventListener('click', () => this.handleSolveClick());
                document.querySelectorAll('input[name="rarity"]').forEach(radio => {
                    radio.addEventListener('change', () => this.drawCreator());
                });
            }

            setupSolverWorker() {
                const workerScript = document.getElementById('solver-worker').textContent;
                const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                this.solverWorker = new Worker(URL.createObjectURL(workerBlob));

                this.solverWorker.onmessage = (e) => {
                    const { type, payload } = e.data;
                    if (type === 'progress') {
                        this.displayMessage(`Solving... (${payload.placementsChecked.toLocaleString()} positions)`, Infinity);
                    } else if (type === 'intermediate_solution') {
                        this.handleIntermediateSolution(payload);
                    } else if (type === 'result') {
                        this.handleSolverResult(payload);
                    }
                };
            }

            createGrids() {
                this.board.grid.clear();
                for (let q = 0; q < this.board.cols; q++) {
                    const rOffset = Math.floor(q / 2);
                    for (let r = -rOffset; r < this.board.rows - rOffset; r++) {
                        const hex = new Hex(q, r);
                        this.board.grid.set(hex.toString(), hex);
                    }
                }
                this.creator.grid.clear();
                for (let q = 0; q < this.creator.cols; q++) {
                    const rOffset = Math.floor(q / 2);
                    for (let r = -rOffset; r < this.creator.rows - rOffset; r++) {
                        const hex = new Hex(q, r);
                        this.creator.grid.set(hex.toString(), hex);
                    }
                }
            }

            handleBoardResize() {
                this.board.cols = parseInt(this.colsInput.value);
                this.board.rows = parseInt(this.rowsInput.value);
                this.solution = null;
                this.createGrids();
                this.resizeAndDrawAll();
            }
            
            handleCreatorClick(event) {
                const rect = this.creatorCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                const hex = this.pixelToHex(x, y, this.creator.renderProps);
                if (this.creator.grid.has(hex.toString())) {
                    const hexStr = hex.toString();
                    if (this.creator.shape.has(hexStr)) {
                        this.creator.shape.delete(hexStr);
                    } else {
                        this.creator.shape.add(hexStr);
                    }
                    this.drawCreator();
                }
            }

            shadeColor(color, percent) {
                let R = parseInt(color.substring(1, 3), 16);
                let G = parseInt(color.substring(3, 5), 16);
                let B = parseInt(color.substring(5, 7), 16);

                R = parseInt(R * (1.0 + percent));
                G = parseInt(G * (1.0 + percent));
                B = parseInt(B * (1.0 + percent));

                R = Math.max(0, Math.min(255, R));
                G = Math.max(0, Math.min(255, G));
                B = Math.max(0, Math.min(255, B));

                const RR = R.toString(16).padStart(2, '0');
                const GG = G.toString(16).padStart(2, '0');
                const BB = B.toString(16).padStart(2, '0');

                return "#" + RR + GG + BB;
            }

            addModToList() {
                if (this.creator.shape.size === 0) return;
                const baseColor = document.querySelector('input[name="rarity"]:checked').value;
                const isPriority = document.getElementById('priority-mod').checked;

                const sameColorCount = this.mods.filter(m => m.baseColor === baseColor).length;
                const shadePercent = (Math.ceil((sameColorCount) / 2) * 0.20) * (sameColorCount % 2 === 1 ? 1 : -1);
                const finalColor = this.shadeColor(baseColor, shadePercent);

                const shapeCoords = Array.from(this.creator.shape).map(s => Hex.fromString(s));
                const firstHex = shapeCoords[0];
                const normalizedShape = shapeCoords.map(h => h.subtract(firstHex));
                
                const newMod = {
                    id: Date.now(),
                    shape: normalizedShape,
                    baseColor: baseColor,
                    color: finalColor,
                    isPriority,
                };
                this.mods.push(newMod);

                this.creator.shape.clear();
                document.getElementById('priority-mod').checked = false;
                this.renderModList();
                this.drawCreator();
                this.updateSolveButtonState();
                this.solution = null;
                this.drawMainBoard();
                this.saveMods();
            }
            
            deleteMod(modId) {
                this.mods = this.mods.filter(m => m.id !== modId);
                this.renderModList();
                this.updateSolveButtonState();
                this.solution = null;
                this.drawMainBoard();
                this.saveMods();
            }

            saveMods() {
                try {
                    const serializableMods = this.mods.map(mod => ({
                        ...mod,
                        shape: mod.shape.map(h => ({ q: h.q, r: h.r }))
                    }));
                    localStorage.setItem('mycopunkSolverMods', JSON.stringify(serializableMods));
                } catch (e) {
                    console.error("Could not save mods to localStorage:", e);
                }
            }

            loadMods() {
                try {
                    const savedMods = localStorage.getItem('mycopunkSolverMods');
                    if (savedMods) {
                        const parsedMods = JSON.parse(savedMods);
                        this.mods = parsedMods.map(mod => ({
                            ...mod,
                            baseColor: mod.baseColor || mod.color,
                            shape: mod.shape.map(hexData => new Hex(hexData.q, hexData.r))
                        }));
                    }
                } catch (e) {
                    console.error("Could not load mods from localStorage:", e);
                    this.mods = [];
                }
            }

            updateSolveButtonState() {
                if (this.isSolving) {
                    this.solveBtn.textContent = 'Cancel';
                    this.solveBtn.classList.add('cancel-btn');
                    this.solveBtn.disabled = false;
                } else {
                    this.solveBtn.textContent = 'Solve Arrangement';
                    this.solveBtn.classList.remove('cancel-btn');
                    this.solveBtn.disabled = this.mods.length === 0;
                }
            }
            
            drawAll() { this.drawMainBoard(); this.drawCreator(); }

            drawMainBoard() {
                this.mainCtx.clearRect(0, 0, this.mainCanvas.width, this.mainCanvas.height);
                const { hexSize, offsetX, offsetY } = this.board.renderProps;
                if (!hexSize || hexSize <= 0) return;
                this.board.grid.forEach(hex => {
                    const center = this.hexToPixel(hex, hexSize);
                    this.drawHexagon(this.mainCtx, center.x + offsetX, center.y + offsetY, hexSize, '#2a2e37', '#3c414d');
                });
                if (this.solution) {
                    this.solution.forEach(placedMod => {
                        placedMod.absoluteShape.forEach(hex => {
                            const center = this.hexToPixel(hex, hexSize);
                            this.drawHexagon(this.mainCtx, center.x + offsetX, center.y + offsetY, hexSize, placedMod.mod.color, 'white', 2);
                        });
                    });
                }
            }

            drawCreator() {
                this.creatorCtx.clearRect(0, 0, this.creatorCanvas.width, this.creatorCanvas.height);
                const { hexSize, offsetX, offsetY } = this.creator.renderProps;
                if (!hexSize || hexSize <= 0) return;
                const selectedColor = document.querySelector('input[name="rarity"]:checked').value;
                this.creator.grid.forEach(hex => {
                    const center = this.hexToPixel(hex, hexSize);
                    const isSelected = this.creator.shape.has(hex.toString());
                    const fillColor = isSelected ? selectedColor : '#111318';
                    const strokeColor = isSelected ? 'white' : '#3c414d';
                    this.drawHexagon(this.creatorCtx, center.x + offsetX, center.y + offsetY, hexSize, fillColor, strokeColor);
                });
            }
            
            renderModList() {
                this.modListContainer.innerHTML = '';
                this.mods.forEach(mod => {
                    const item = document.createElement('div');
                    item.className = 'mod-item';
                    item.innerHTML = `<canvas class="mod-preview-canvas" data-mod-id="${mod.id}"></canvas><div class="mod-item-info"><span>${mod.shape.length}-hex Mod</span><p>${mod.isPriority ? 'Priority Mod' : 'Standard Mod'}</p></div><button class="mod-delete-btn" data-id="${mod.id}"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg></button>`;
                    this.modListContainer.appendChild(item);
                });
                this.modListContainer.querySelectorAll('.mod-delete-btn').forEach(btn => btn.addEventListener('click', (e) => this.deleteMod(parseInt(e.currentTarget.dataset.id))));
                this.modListContainer.querySelectorAll('.mod-preview-canvas').forEach(canvas => {
                    const mod = this.mods.find(m => m.id === parseInt(canvas.dataset.modId));
                    if (mod) this.drawModPreview(canvas, mod);
                });
            }
            
            drawModPreview(canvas, mod) {
                const ctx = canvas.getContext('2d');
                canvas.width = 60; canvas.height = 60;
                const bounds = this.getShapeBounds(mod.shape);
                const props = this.calculateRenderProps(canvas.width, canvas.height, bounds.cols, bounds.rows, true);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                mod.shape.forEach(hex => {
                    const relativeHex = hex.subtract(new Hex(bounds.minQ, bounds.minR));
                    const center = this.hexToPixel(relativeHex, props.hexSize);
                    this.drawHexagon(ctx, center.x + props.offsetX, center.y + props.offsetY, props.hexSize, mod.color, '#cdd2da', 1.5);
                });
            }

            drawHexagon(ctx, x, y, size, fill, stroke, lineWidth = 1.5) {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = 2 * Math.PI / 6 * i;
                    ctx[i === 0 ? 'moveTo' : 'lineTo'](x + size * Math.cos(angle), y + size * Math.sin(angle));
                }
                ctx.closePath();
                ctx.fillStyle = fill;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = lineWidth;
                ctx.fill();
                ctx.stroke();
            }

            hexToPixel(hex, size) {
                const x = size * (3/2 * hex.q);
                const y = size * (Math.sqrt(3)/2 * hex.q + Math.sqrt(3) * hex.r);
                return { x, y };
            }

            pixelToHex(x, y, { hexSize, offsetX, offsetY }) {
                if (!hexSize) return new Hex(0,0);
                const pt = { x: (x - offsetX) / hexSize, y: (y - offsetY) / hexSize };
                const q = (2/3 * pt.x);
                const r = (-1/3 * pt.x + Math.sqrt(3)/3 * pt.y);
                return this.hexRound(new Hex(q, r));
            }
            
            hexRound(hex) {
                let q = Math.round(hex.q), r = Math.round(hex.r), s = Math.round(hex.s);
                const q_diff = Math.abs(q - hex.q), r_diff = Math.abs(r - hex.r), s_diff = Math.abs(s - hex.s);
                if (q_diff > r_diff && q_diff > s_diff) q = -r - s;
                else if (r_diff > s_diff) r = -q - s;
                return new Hex(q, r);
            }

            resizeAndDrawAll() {
                const mainContainer = document.getElementById('canvas-container');
                this.board.renderProps = this.calculateRenderProps(mainContainer.clientWidth, mainContainer.clientHeight, this.board.cols, this.board.rows, false);
                this.mainCanvas.width = mainContainer.clientWidth;
                this.mainCanvas.height = mainContainer.clientHeight;
                const creatorContainer = document.getElementById('creator-canvas-container');
                this.creator.renderProps = this.calculateRenderProps(creatorContainer.clientWidth, creatorContainer.clientHeight, this.creator.cols, this.creator.rows, true);
                this.creatorCanvas.width = creatorContainer.clientWidth;
                this.creatorCanvas.height = creatorContainer.clientHeight;
                this.renderModList();
                this.drawAll();
            }
            
            calculateRenderProps(cWidth, cHeight, gCols, gRows, isPreview) {
                const PADDING = isPreview ? 0.9 : 0.95;
                const HEX_WIDTH_MULTI = 1.5;
                const HEX_HEIGHT_MULTI = Math.sqrt(3);
                const gridWidth = (gCols * HEX_WIDTH_MULTI) + 0.5;
                const gridHeight = (gRows * HEX_HEIGHT_MULTI) + (gCols > 1 ? HEX_HEIGHT_MULTI / 2 : 0);
                const sizeFromWidth = (cWidth * PADDING) / gridWidth;
                const sizeFromHeight = (cHeight * PADDING) / gridHeight;
                const hexSize = Math.max(1, Math.min(sizeFromWidth, sizeFromHeight));
                const totalPixelWidth = gridWidth * hexSize;
                const totalPixelHeight = gridHeight * hexSize;
                const offsetX = (cWidth - totalPixelWidth) / 2 + (hexSize);
                const offsetY = (cHeight - totalPixelHeight) / 2 + (hexSize * HEX_HEIGHT_MULTI / 2);
                return { hexSize, offsetX, offsetY };
            }
            
            getShapeBounds(shape) {
                if (shape.length === 0) return { minQ: 0, maxQ: 0, minR: 0, maxR: 0, cols: 1, rows: 1 };
                let minQ = Infinity, maxQ = -Infinity, minR = Infinity, maxR = -Infinity;
                shape.forEach(h => {
                    minQ = Math.min(minQ, h.q); maxQ = Math.max(maxQ, h.q);
                    minR = Math.min(minR, h.r); maxR = Math.max(maxR, h.r);
                });
                return { minQ, maxQ, minR, maxR, cols: maxQ - minQ + 1, rows: maxR - minR + 1 };
            }

            handleSolveClick() {
                if (this.isSolving) {
                    this.solverWorker.postMessage({ type: 'cancel' });
                } else {
                    this.solve();
                }
            }

            solve() {
                this.isSolving = true;
                this.solution = null; // Clear previous solution from display
                this.updateSolveButtonState();
                this.drawMainBoard();
                this.displayMessage('Starting solver...', Infinity);

                const totalModArea = this.mods.reduce((sum, mod) => sum + mod.shape.length, 0);
                if (totalModArea > this.board.grid.size) {
                    this.displayMessage('Not enough space on board!', 3000);
                    this.isSolving = false;
                    this.updateSolveButtonState();
                    return;
                }

                const serializableBoard = {
                    grid: Array.from(this.board.grid.values()).map(h => ({ q: h.q, r: h.r }))
                };
                const serializableMods = this.mods.map(mod => ({
                    ...mod,
                    shape: mod.shape.map(h => ({ q: h.q, r: h.r }))
                }));

                this.solverWorker.postMessage({
                    type: 'solve',
                    payload: { board: serializableBoard, mods: serializableMods }
                });
            }

            handleIntermediateSolution({ solution, connections }) {
                this.solution = solution.map(p => ({
                    mod: { ...p.mod, shape: p.mod.shape.map(h => new Hex(h.q, h.r)) },
                    absoluteShape: p.absoluteShape.map(h => new Hex(h.q, h.r))
                }));
                this.displayMessage(`Found solution with ${connections} connections... Searching for better...`, Infinity);
                this.drawMainBoard();
            }
            
            handleSolverResult({ solution, placementsChecked }) {
                this.isSolving = false;
                this.updateSolveButtonState();

                if (solution) {
                    this.solution = solution.map(p => ({
                        mod: { ...p.mod, shape: p.mod.shape.map(h => new Hex(h.q, h.r)) },
                        absoluteShape: p.absoluteShape.map(h => new Hex(h.q, h.r))
                    }));
                    this.displayMessage(`Solution Found! (${placementsChecked.toLocaleString()} positions)`, 4000);
                } else {
                    if (!this.solution) {
                        this.displayMessage(`No Solution Found. (${placementsChecked.toLocaleString()} positions)`, 4000);
                    } else {
                        this.displayMessage(`Search Complete! Best solution retained. (${placementsChecked.toLocaleString()} positions)`, 4000);
                    }
                }
                this.drawMainBoard();
            }

            displayMessage(msg, duration) {
                this.statusMessageEl.textContent = msg;
                this.statusMessageEl.style.opacity = 1;
                if (this.messageTimeout) clearTimeout(this.messageTimeout);
                if (duration !== Infinity) {
                    this.messageTimeout = setTimeout(() => { this.statusMessageEl.style.opacity = 0; }, duration);
                }
            }
        }

        window.onload = () => new ModSolverApp();
    </script>
</body>
</html>
